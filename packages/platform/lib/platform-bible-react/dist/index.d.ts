// Generated by dts-bundle-generator v9.5.1

import * as CheckboxPrimitive from '@radix-ui/react-checkbox';
import * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu';
import * as LabelPrimitive from '@radix-ui/react-label';
import { PopoverProps } from '@radix-ui/react-popover';
import * as RadioGroupPrimitive from '@radix-ui/react-radio-group';
import * as SelectPrimitive from '@radix-ui/react-select';
import * as SeparatorPrimitive from '@radix-ui/react-separator';
import * as SliderPrimitive from '@radix-ui/react-slider';
import * as SwitchPrimitives from '@radix-ui/react-switch';
import * as TabsPrimitive from '@radix-ui/react-tabs';
import * as ToggleGroupPrimitive from '@radix-ui/react-toggle-group';
import { ColumnDef as TSColumnDef, Row as TSRow, SortDirection as TSSortDirection, Table as TSTable } from '@tanstack/react-table';
import { VariantProps } from 'class-variance-authority';
import { ClassValue } from 'clsx';
import { LucideProps } from 'lucide-react';
import React$1 from 'react';
import { ChangeEventHandler, ComponentProps, FocusEventHandler, MouseEvent as MouseEvent$1, MouseEventHandler, MutableRefObject, PropsWithChildren, ReactNode } from 'react';
import { Toaster, toast as sonner } from 'sonner';

/** Function to run to dispose of something. Returns true if successfully unsubscribed */
export type Unsubscriber = () => boolean;
/**
 * Function to run to dispose of something that runs asynchronously. The promise resolves to true if
 * successfully unsubscribed
 */
export type UnsubscriberAsync = () => Promise<boolean>;
/** Callback function that accepts an event and should run when an event is emitted */
export type PlatformEventHandler<T> = (event: T) => void;
/**
 * Function that subscribes the provided callback to run when this event is emitted.
 *
 * @param callback Function to run with the event when it is emitted
 * @returns Unsubscriber function to run to stop calling the passed-in function when the event is
 *   emitted
 */
export type PlatformEvent<T> = (callback: PlatformEventHandler<T>) => Unsubscriber;
/**
 * A PapiEvent that subscribes asynchronously and resolves an asynchronous unsubscriber.
 *
 * Note: The callback itself is not asynchronous.
 */
export type PlatformEventAsync<T> = (callback: PlatformEventHandler<T>) => Promise<UnsubscriberAsync>;
export interface ScriptureReference {
	bookNum: number;
	chapterNum: number;
	verseNum: number;
}
/**
 * Represents a "node" in the JSON used to present Scripture in the editor, with a path that is
 * relative to the start of a verse.
 */
export type ScriptureNode = ScriptureReference & {
	jsonPath: string;
};
/** Represents a specific character offset in the text of a textual Scripture node (in the editor.) */
export type ScriptureTextAnchor = ScriptureNode & {
	offset: number;
};
/**
 * Represents a range of text in the Scripture editor. The start and end node are expected to be in
 * the same book.
 */
export type ScriptureSelection = {
	start: ScriptureNode | ScriptureTextAnchor;
	end?: ScriptureNode | ScriptureTextAnchor;
};
/**
 * An identifier corresponding to a Scripture reference shared by a group of Scripture reference
 * consumers.
 *
 * For example, a few web views that share a Scroll Group Id would all change Scripture Reference
 * together.
 *
 * These are generally expected to be non-negative numbers (starting at 0).
 */
export type ScrollGroupId = number;
/** Within type T, recursively change properties that were of type A to be of type B */
export type ReplaceType<T, A, B> = T extends A ? B : T extends object ? {
	[K in keyof T]: ReplaceType<T[K], A, B>;
} : T;
/** Identifier for a string that will be localized in a menu based on the user's UI language */
export type LocalizeKey = `%${string}%`;
/** Name of some UI element (i.e., tab, column, group, menu item) or some PAPI object (i.e., command) */
export type ReferencedItem = `${string}.${string}`;
export type OrderedItem = {
	/** Relative order of this item compared to other items in the same parent/scope (sorted ascending) */
	order: number;
};
export type OrderedExtensibleContainer = OrderedItem & {
	/** Determines whether other items can be added to this after it has been defined */
	isExtensible?: boolean;
};
/** Group of menu items that belongs in a column */
export type MenuGroupDetailsInColumn = OrderedExtensibleContainer & {
	/** ID of column in which this group resides */
	column: ReferencedItem;
};
/** Group of menu items that belongs in a submenu */
export type MenuGroupDetailsInSubMenu = OrderedExtensibleContainer & {
	/** ID of menu item hosting the submenu in which this group resides */
	menuItem: ReferencedItem;
};
/** Column that includes header text in a menu */
export type MenuColumnWithHeader = OrderedExtensibleContainer & {
	/** Key that represents the text of the header text of the column */
	label: LocalizeKey;
};
export type MenuItemBase = OrderedItem & {
	/** Menu group to which this menu item belongs */
	group: ReferencedItem;
	/** Key that represents the text of this menu item to display */
	label: LocalizeKey;
	/** Key that represents words the platform should reference when users are searching for menu items */
	searchTerms?: LocalizeKey;
	/** Key that represents the text to display if a mouse pointer hovers over the menu item */
	tooltip?: LocalizeKey;
	/** Additional information provided by developers to help people who perform localization */
	localizeNotes: string;
};
/** Menu item that hosts a submenu */
export type MenuItemContainingSubmenu = MenuItemBase & {
	/** ID for this menu item that holds a submenu */
	id: ReferencedItem;
};
/** Menu item that runs a command */
export type MenuItemContainingCommand = MenuItemBase & {
	/** Name of the PAPI command to run when this menu item is selected. */
	command: ReferencedItem;
	/**
	 * Uri path to the icon to display after the menu text. Ex:
	 * `papi-extension://helloWorld/assets/icon.png`
	 */
	iconPathAfter?: string;
	/**
	 * Uri path to the icon to display before the menu text. Ex:
	 * `papi-extension://helloWorld/assets/icon.png`
	 */
	iconPathBefore?: string;
};
/**
 * Group of menu items that can be combined with other groups to form a single context menu/submenu.
 * Groups are separated using a line within the menu/submenu.
 */
export type GroupsInSingleColumnMenu = {
	/** Named menu group */
	[property: ReferencedItem]: OrderedExtensibleContainer | MenuGroupDetailsInSubMenu;
};
/**
 * Group of menu items that can be combined with other groups to form a single menu/submenu within a
 * multi-column menu. Groups are separated using a line within the menu/submenu.
 */
export type GroupsInMultiColumnMenu = {
	/** Named menu group */
	[property: ReferencedItem]: MenuGroupDetailsInColumn | MenuGroupDetailsInSubMenu;
};
/** Group of columns that can be combined with other columns to form a multi-column menu */
export type ColumnsWithHeaders = {
	/** Named column of a menu */
	[property: ReferencedItem]: MenuColumnWithHeader;
	/** Defines whether columns can be added to this multi-column menu */
	isExtensible?: boolean;
};
/** Menu that contains a column without a header */
export type SingleColumnMenu = {
	/** Groups that belong in this menu */
	groups: GroupsInSingleColumnMenu;
	/** List of menu items that belong in this menu */
	items: (MenuItemContainingCommand | MenuItemContainingSubmenu)[];
};
/** Menu that contains multiple columns with headers */
export type MultiColumnMenu = {
	/** Columns that belong in this menu */
	columns: ColumnsWithHeaders;
	/** Groups that belong in this menu */
	groups: GroupsInMultiColumnMenu;
	/** List of menu items that belong in this menu */
	items: (MenuItemContainingCommand | MenuItemContainingSubmenu)[];
};
/**
 * Type that converts any menu type before it is localized to what it is after it is localized. This
 * can be applied to any menu type as needed.
 */
export type Localized<T> = ReplaceType<ReplaceType<T, LocalizeKey, string>, ReferencedItem, string>;
/** Localized string value associated with this key */
export type LocalizedStringValue = string;
/**
 * Map whose keys are localized string keys and whose values provide information about how to
 * localize strings for the localized string key
 */
export interface LanguageStrings {
	[k: LocalizeKey]: LocalizedStringValue;
}
export type BookChapterControlProps = {
	scrRef: ScriptureReference;
	handleSubmit: (scrRef: ScriptureReference) => void;
};
export declare function BookChapterControl({ scrRef, handleSubmit }: BookChapterControlProps): import("react/jsx-runtime").JSX.Element;
export type ChapterRangeSelectorProps = {
	startChapter: number;
	endChapter: number;
	handleSelectStartChapter: (chapter: number) => void;
	handleSelectEndChapter: (chapter: number) => void;
	isDisabled?: boolean;
	chapterCount: number;
};
export function ChapterRangeSelector({ startChapter, endChapter, handleSelectStartChapter, handleSelectEndChapter, isDisabled, chapterCount, }: ChapterRangeSelectorProps): import("react/jsx-runtime").JSX.Element;
export declare enum BookSelectionMode {
	CURRENT_BOOK = "current book",
	CHOOSE_BOOKS = "choose books"
}
/**
 * Object containing all keys used for localization in this component. If you're using this
 * component in an extension, you can pass it into the useLocalizedStrings hook to easily obtain the
 * localized strings and pass them into the localizedStrings prop of this component
 */
export declare const BOOK_SELECTOR_STRING_KEYS: readonly [
	"%webView_bookSelector_currentBook%",
	"%webView_bookSelector_choose%",
	"%webView_bookSelector_chooseBooks%"
];
export type BookSelectorLocalizedStrings = {
	[localizedInventoryKey in (typeof BOOK_SELECTOR_STRING_KEYS)[number]]?: LocalizedStringValue;
};
export type BookSelectorProps = ChapterRangeSelectorProps & {
	handleBookSelectionModeChange: (newMode: BookSelectionMode) => void;
	currentBookName: string;
	onSelectBooks: () => void;
	selectedBookIds: string[];
	localizedStrings: BookSelectorLocalizedStrings;
};
export function BookSelector({ handleBookSelectionModeChange, currentBookName, onSelectBooks, selectedBookIds, chapterCount, endChapter, handleSelectEndChapter, startChapter, handleSelectStartChapter, localizedStrings, }: BookSelectorProps): import("react/jsx-runtime").JSX.Element;
export type ColumnDef<TData, TValue = unknown> = TSColumnDef<TData, TValue>;
export type RowContents<TData> = TSRow<TData>;
export type TableContents<TData> = TSTable<TData>;
export type SortDirection = TSSortDirection;
export interface DataTableProps<TData, TValue> {
	columns: ColumnDef<TData, TValue>[];
	data: TData[];
	enablePagination?: boolean;
	showPaginationControls?: boolean;
	showColumnVisibilityControls?: boolean;
	stickyHeader?: boolean;
	onRowClickHandler?: (row: RowContents<TData>, table: TableContents<TData>) => void;
}
/**
 * Feature-rich table component that infuses our basic shadcn-based Table component with features
 * from TanStack's React Table library
 */
export declare function DataTable<TData, TValue>({ columns, data, enablePagination, showPaginationControls, showColumnVisibilityControls, stickyHeader, onRowClickHandler, }: DataTableProps<TData, TValue>): import("react/jsx-runtime").JSX.Element;
/**
 * Object containing all keys used for localization in this component. If you're using this
 * component in an extension, you can pass it into the useLocalizedStrings hook to easily obtain the
 * localized strings and pass them into the localizedStrings prop of this component
 */
export declare const INVENTORY_STRING_KEYS: readonly [
	"%webView_inventory_all%",
	"%webView_inventory_approved%",
	"%webView_inventory_unapproved%",
	"%webView_inventory_unknown%",
	"%webView_inventory_scope_currentBook%",
	"%webView_inventory_scope_chapter%",
	"%webView_inventory_scope_verse%",
	"%webView_inventory_filter_text%",
	"%webView_inventory_occurrences_table_header_reference%",
	"%webView_inventory_occurrences_table_header_occurrence%"
];
export type InventoryLocalizedStrings = {
	[localizedInventoryKey in (typeof INVENTORY_STRING_KEYS)[number]]?: LocalizedStringValue;
};
export type Scope = "book" | "chapter" | "verse";
export type Status = "approved" | "unapproved" | "unknown";
export type ItemData = {
	item: string;
	count: number;
	status: Status;
};
/**
 * Gets an icon that indicates the current sorting direction based on the provided input
 *
 * @param sortDirection Sorting direction. Can be ascending ('asc'), descending ('desc') or false (
 *   i.e. not sorted)
 * @returns The appropriate sorting icon for the provided sorting direction
 */
export declare const getSortingIcon: (sortDirection: false | SortDirection) => React$1.ReactNode;
export type InventoryProps = {
	scriptureReference: ScriptureReference;
	setScriptureReference: (scriptureReference: ScriptureReference) => void;
	localizedStrings: InventoryLocalizedStrings;
	extractItems: (text: string, item?: string | undefined) => string[];
	approvedItems: string[];
	onApprovedItemsChange: (items: string[]) => void;
	unapprovedItems: string[];
	onUnapprovedItemsChange: (items: string[]) => void;
	text: string | undefined;
	scope: Scope;
	onScopeChange: (scope: Scope) => void;
	getColumns: (onStatusChange: (newItems: string[], status: Status) => void) => ColumnDef<ItemData>[];
};
/** Inventory component that is used to view and control the status of provided project settings */
export function Inventory({ scriptureReference, setScriptureReference, localizedStrings, extractItems, approvedItems, onApprovedItemsChange, unapprovedItems, onUnapprovedItemsChange, text, scope, onScopeChange, getColumns, }: InventoryProps): import("react/jsx-runtime").JSX.Element;
/**
 * Function that creates the item column for inventories
 *
 * @param itemLabel Localized label for the item column (e.g. 'Character', 'Repeated Word', etc.)
 * @returns Column that shows the inventory items. Should be used with the DataTable component
 */
export declare const inventoryItemColumn: (itemLabel: string) => ColumnDef<ItemData>;
/**
 * Function that creates the count column for inventories. Should be used with the DataTable
 * component.
 *
 * @param itemLabel Localized label for the count column
 * @returns Column that shows the number of occurrences of the related inventory items
 */
export declare const inventoryCountColumn: (countLabel: string) => ColumnDef<ItemData>;
/**
 * Function that creates the status column for inventories. Should be used with the DataTable
 * component.
 *
 * @param itemLabel Localized label for the status column
 * @param statusChangeHandler Callback function that handles status updates to selected item(s)
 * @returns Column that shows the status of the related inventory items.
 */
export declare const inventoryStatusColumn: (statusLabel: string, statusChangeHandler: (items: string[], status: Status) => void) => ColumnDef<ItemData>;
export type TabKeyValueContent = {
	key: string;
	value: string;
	content: React$1.ReactNode;
};
export type NavigationContentSearchProps = {
	/** List of values and keys for each tab this component should provide */
	tabList: TabKeyValueContent[];
	/** Handler to run when the value of the search bar changes */
	onSearch: (searchQuery: string) => void;
	/** Optional placeholder for the search bar */
	searchPlaceholder?: string;
	/** Optional title to include in the header */
	headerTitle?: string;
	/** Optional flag to make the search bar appear full width */
	isSearchBarFullWidth?: boolean;
	/** Text direction ltr or rtl */
	direction?: "ltr" | "rtl";
};
export function NavigationContentSearch({ tabList, onSearch, searchPlaceholder, headerTitle, isSearchBarFullWidth, direction, }: NavigationContentSearchProps): import("react/jsx-runtime").JSX.Element;
/**
 * Information (e.g., a checking error or some other type of "transient" annotation) about something
 * noteworthy at a specific place in an instance of the Scriptures.
 */
export type ScriptureItemDetail = ScriptureSelection & {
	/**
	 * Text of the error, note, etc. In the future, we might want to support something more than just
	 * text so that a JSX element could be provided with a link or some other controls related to the
	 * issue being reported.
	 */
	detail: string;
};
/**
 * A uniquely identifiable source of results that can be displayed in the ScriptureResultsViewer.
 * Generally, the source will be a particular Scripture check, but there may be other types of
 * sources.
 */
export type ResultsSource = {
	/**
	 * Uniquely identifies the source.
	 *
	 * @type {string}
	 */
	id: string;
	/**
	 * Name (potentially localized) of the source, suitable for display in the UI.
	 *
	 * @type {string}
	 */
	displayName: string;
};
export type ScriptureSrcItemDetail = ScriptureItemDetail & {
	/** Source/type of detail. Can be used for grouping. */
	source: ResultsSource;
};
/**
 * Represents a set of results keyed by Scripture reference. Generally, the source will be a
 * particular Scripture check, but this type also allows for other types of uniquely identifiable
 * sources.
 */
export type ResultsSet = {
	/**
	 * The backing source associated with this set of results.
	 *
	 * @type {ResultsSource}
	 */
	source: ResultsSource;
	/**
	 * Array of Scripture item details (messages keyed by Scripture reference).
	 *
	 * @type {ScriptureItemDetail[]}
	 */
	data: ScriptureItemDetail[];
};
export type ScriptureResultsViewerColumnInfo = {
	/** Optional header to display for the Reference column. Default value: 'Scripture Reference'. */
	scriptureReferenceColumnName?: string;
	/** Optional text to display to refer to the Scripture book group. Default value: 'Scripture Book'. */
	scriptureBookGroupName?: string;
	/** Optional header to display for the Type column. Default value: 'Type'. */
	typeColumnName?: string;
	/** Optional header to display for the Details column. Default value: 'Details' */
	detailsColumnName?: string;
};
export type ScriptureResultsViewerProps = ScriptureResultsViewerColumnInfo & {
	/** Groups of ScriptureItemDetail objects from particular sources (e.g., Scripture checks) */
	sources: ResultsSet[];
	/** Flag indicating whether to display column headers. Default is false. */
	showColumnHeaders?: boolean;
	/** Flag indicating whether to display source column. Default is false. */
	showSourceColumn?: boolean;
	/** Callback function to notify when a row is selected */
	onRowSelected?: (selectedRow: ScriptureSrcItemDetail | undefined) => void;
	/** Text direction ltr or rtl */
	direction?: "ltr" | "rtl";
};
/**
 * Component to display a combined list of detailed items from one or more sources, where the items
 * are keyed primarily by Scripture reference. This is particularly useful for displaying a list of
 * results from Scripture checks, but more generally could be used to display any "results" from any
 * source(s). The component allows for grouping by Scripture book, source, or both. By default, it
 * displays somewhat "tree-like" which allows it to be more horizontally compact and intuitive. But
 * it also has the option of displaying as a traditional table with column headings (with or without
 * the source column showing).
 */
export function ScriptureResultsViewer({ sources, showColumnHeaders, showSourceColumn, scriptureReferenceColumnName, scriptureBookGroupName, typeColumnName, detailsColumnName, onRowSelected, direction, }: ScriptureResultsViewerProps): import("react/jsx-runtime").JSX.Element;
export type ScrollGroupSelectorProps = {
	/**
	 * List of scroll group ids to show to the user. Either a {@link ScrollGroupId} or `undefined` for
	 * no scroll group
	 */
	availableScrollGroupIds: (ScrollGroupId | undefined)[];
	/** Currently selected scroll group id. `undefined` for no scroll group */
	scrollGroupId: ScrollGroupId | undefined;
	/** Callback function run when the user tries to change the scroll group id */
	onChangeScrollGroupId: (newScrollGroupId: ScrollGroupId | undefined) => void;
	/**
	 * Localized strings to use for displaying scroll group ids. Must be an object whose keys are
	 * `getLocalizeKeyForScrollGroupId(scrollGroupId)` for all scroll group ids (and `undefined` if
	 * included) in {@link ScrollGroupSelectorProps.availableScrollGroupIds} and whose values are the
	 * localized strings to use for those scroll group ids.
	 *
	 * Defaults to English localizations of English alphabet for scroll groups 0-25 (e.g. 0 is A) and
	 * Ø for `undefined`. Will fill in any that are not provided with these English localizations.
	 * Also, if any values match the keys, the English localization will be used. This is useful in
	 * case you want to pass in a temporary version of the localized strings while your localized
	 * strings load.
	 *
	 * @example
	 *
	 * ```typescript
	 * const myScrollGroupIdLocalizedStrings = {
	 *   [getLocalizeKeyForScrollGroupId('undefined')]: 'Ø',
	 *   [getLocalizeKeyForScrollGroupId(0)]: 'A',
	 *   [getLocalizeKeyForScrollGroupId(1)]: 'B',
	 *   [getLocalizeKeyForScrollGroupId(2)]: 'C',
	 *   [getLocalizeKeyForScrollGroupId(3)]: 'D',
	 *   [getLocalizeKeyForScrollGroupId(4)]: 'E',
	 * };
	 * ```
	 *
	 * @example
	 *
	 * ```tsx
	 * const availableScrollGroupIds = [undefined, 0, 1, 2, 3, 4];
	 *
	 * const localizeKeys = getLocalizeKeysForScrollGroupIds();
	 *
	 * const [localizedStrings] = useLocalizedStrings(localizeKeys);
	 *
	 * ...
	 *
	 * <ScrollGroupSelector localizedStrings={localizedStrings} />
	 * ```
	 */
	localizedStrings?: LanguageStrings;
};
/** Selector component for choosing a scroll group */
export function ScrollGroupSelector({ availableScrollGroupIds, scrollGroupId, onChangeScrollGroupId, localizedStrings, }: ScrollGroupSelectorProps): import("react/jsx-runtime").JSX.Element;
/** Props for the SettingsList component, currently just children */
export type SettingsListProps = React$1.PropsWithChildren;
/**
 * SettingsList component is a wrapper for list items. Rendered with a formatted div
 *
 * @param children To populate the list with
 * @returns Formatted div encompassing the children
 */
export declare function SettingsList({ children }: SettingsListProps): import("react/jsx-runtime").JSX.Element;
/** Props for SettingsListItem component */
export type SettingsListItemProps = React$1.PropsWithChildren & {
	/** Primary text of the list item */
	primary: string;
	/** Optional text of the list item */
	secondary?: string | undefined;
	/** Optional boolean to display a message if the children aren't loaded yet. Defaults to false */
	isLoading?: boolean;
	/** Optional message to display if isLoading */
	loadingMessage?: string;
};
/**
 * SettingsListItem component is a common list item. Rendered with a formatted div
 *
 * @param primary Primary text of the list item
 * @param secondary Optional secondary text of the list item
 * @param isLoading Optional, to display a message if the action component isn't generated yet,
 *   defaults to false
 * @param children The action component(s) to provide for this item
 * @param loadingMessage Optional, message to display if isLoading
 * @returns Formatted div encompassing the list item content
 */
export declare function SettingsListItem({ primary, secondary, children, isLoading, loadingMessage, }: SettingsListItemProps): import("react/jsx-runtime").JSX.Element;
/** Props for SettingsListHeader component */
export type SettingsListHeaderProps = {
	/** The primary text of the list header */
	primary: string;
	/** Optional secondary text of the list header */
	secondary?: string | undefined;
	/** Optional boolean to include a separator underneath the secondary text. Defaults to false */
	includeSeparator?: boolean;
};
/**
 * SettingsListHeader component displays text above the list
 *
 * @param primary The primary text of the list header
 * @param secondary Optional secondary text of the list header
 * @param includeSeparator Optional boolean to include a separator underneath the secondary text.
 *   Defaults to false
 * @returns Formatted div with list header content
 */
export declare function SettingsListHeader({ primary, secondary, includeSeparator, }: SettingsListHeaderProps): import("react/jsx-runtime").JSX.Element;
export type ChecklistProps = {
	/** Optional string representing the id attribute of the Checklist */
	id?: string;
	/** Optional string representing CSS class name(s) for styling */
	className?: string;
	/** Array of strings representing the checkable items */
	listItems: string[];
	/** Array of strings representing the checked items */
	selectedListItems: string[];
	/**
	 * Function that is called when a checkbox item is selected or deselected
	 *
	 * @param item The string description for this item
	 * @param selected True if selected, false if not selected
	 */
	handleSelectListItem: (item: string, selected: boolean) => void;
	/**
	 * Optional function creates a label for a provided checkable item
	 *
	 * @param item The item for which a label is to be created
	 * @returns A string representing the label text for the checkbox associated with that item
	 */
	createLabel?: (item: string) => string;
};
/** Renders a list of checkboxes. Each checkbox corresponds to an item from the `listItems` array. */
export function Checklist({ id, className, listItems, selectedListItems, handleSelectListItem, createLabel, }: ChecklistProps): import("react/jsx-runtime").JSX.Element;
export declare const buttonVariants: (props?: ({
	variant?: "link" | "default" | "outline" | "destructive" | "secondary" | "ghost" | null | undefined;
	size?: "default" | "icon" | "sm" | "lg" | null | undefined;
} & import("class-variance-authority/dist/types").ClassProp) | undefined) => string;
export interface ButtonProps extends React$1.ButtonHTMLAttributes<HTMLButtonElement>, VariantProps<typeof buttonVariants> {
	asChild?: boolean;
}
export declare const Button: React$1.ForwardRefExoticComponent<ButtonProps & React$1.RefAttributes<HTMLButtonElement>>;
export type ComboBoxLabelOption = {
	label: string;
};
export type ComboBoxOption = string | number | ComboBoxLabelOption;
export type ComboBoxProps<T> = {
	/** Optional unique identifier */
	id?: string;
	/** Text label title for combobox */
	/** List of available options for the dropdown menu */
	options?: readonly T[];
	/** Additional css classes to help with unique styling of the combo box */
	className?: string;
	/**
	 * The selected value that the combo box currently holds. Must be shallow equal to one of the
	 * options entries.
	 */
	value?: T;
	/** Triggers when content of textfield is changed */
	onChange?: (newValue: T) => void;
	/** Used to determine the string value for a given option. */
	getOptionLabel?: (option: ComboBoxOption) => string;
	/** Text displayed on button if `value` is undefined */
	buttonPlaceholder?: string;
	/** Placeholder text for text field */
	textPlaceholder?: string;
	/** Text to display when no options match input */
	commandEmptyMessage?: string;
	/** Variant of button */
	buttonVariant?: ButtonProps["variant"];
	/** Text direction ltr or rtl */
	dir?: Direction;
	/** Optional boolean to set if trigger should be disabled */
	isDisabled?: boolean;
} & PopoverProps;
export type Direction = "ltr" | "rtl";
/**
 * Autocomplete input and command palette with a list of suggestions.
 *
 * Thanks to Shadcn for heavy inspiration and documentation
 * https://ui.shadcn.com/docs/components/combobox
 */
export declare function ComboBox<T extends ComboBoxOption = ComboBoxOption>({ id, options, className, value, onChange, getOptionLabel, buttonPlaceholder, textPlaceholder, commandEmptyMessage, buttonVariant, dir, isDisabled, ...props }: ComboBoxProps<T>): import("react/jsx-runtime").JSX.Element;
export type MenuItemInfoBase = {
	/** Text (displayable in the UI) as the name of the menu item */
	label: string;
	/** Text to display when the mouse hovers over the menu item */
	tooltip?: string;
};
export type Command = MenuItemInfoBase & {
	/** Command to execute (string.string) */
	command: string;
};
export type SubMenu = MenuItemInfoBase & {
	/** Command to execute (string.string) */
	items: MenuItemInfo[];
};
export interface CommandHandler {
	(command: Command): void;
}
export type MenuPropsBase = {
	menuDefinition: Localized<SingleColumnMenu>;
	commandHandler: CommandHandler;
	/**
	 * Additional action to perform when any menu item is clicked. Allows the caller to handle event
	 * (e.g., to close the menu).
	 */
	onClick?: (event: React$1.MouseEvent<HTMLElement>) => void;
};
export type MenuItemListProps = MenuPropsBase & {
	/** Optional unique (column) identifier */
	columnId?: ReferencedItem;
};
export type MenuItemProps = Omit<MenuItemInfo, "command"> & React$1.PropsWithChildren<{
	/** Optional unique identifier */
	id?: string;
	onClick: (event: React$1.MouseEvent<HTMLElement>) => void;
}>;
export type MenuItemInfo = (Command | SubMenu) & {
	/**
	 * If specified, menu item will be inset if it does not have a leading icon.
	 *
	 * @default true
	 */
	allowForLeadingIcons?: boolean;
	/**
	 * If specified, the path to the icon image to display on the leading side of the menu text.
	 *
	 * @default undefined (no leading icon will be shown)
	 */
	iconPathBefore?: string;
	/**
	 * If specified, the path to the icon image to display on the trailing side of the menu text.
	 *
	 * @default undefined (no trailing icon will be shown)
	 */
	iconPathAfter?: string;
	/**
	 * If true, list item is focused during the first mount
	 *
	 * @default false
	 */
	hasAutoFocus?: boolean;
	/** Additional css classes to help with unique styling of the menu item */
	className?: string;
	/**
	 * If true, the menu item will appear disabled and it will not respond to clicks or mouse hovers.
	 *
	 * @default false
	 */
	isDisabled?: boolean;
	/**
	 * If true, compact vertical padding designed for keyboard and mouse input is used.
	 *
	 * @default true
	 */
	isDense?: boolean;
	/**
	 * If true, a right-arrow icon will be displayed (iconPathAfter, if specified, will be ignored).
	 *
	 * @default false
	 */
	isSubMenuParent?: boolean;
	/**
	 * If true, the left and right padding is removed
	 *
	 * @default false
	 */
	hasDisabledGutters?: boolean;
	/**
	 * If true, a 1px light border is added to bottom of menu item
	 *
	 * @default false
	 */
	hasDivider?: boolean;
	/** Help identify which element has keyboard focus */
	focusVisibleClassName?: string;
	/** If it's a submenu, it should have the items property */
	items?: MenuItemInfo[];
};
export function MenuItem(props: MenuItemProps): import("react/jsx-runtime").JSX.Element;
export type GridMenuInfo = {
	/** The menu object containing information about the columns, groups, and items to display. */
	multiColumnMenu: Localized<MultiColumnMenu>;
};
export type GridMenuProps = GridMenuInfo & {
	/** Optional unique identifier */
	id?: string;
	commandHandler: CommandHandler;
	/** Additional css classes to help with unique styling of the grid menu */
	className?: string;
};
export function GridMenu({ commandHandler, className, multiColumnMenu, id, }: GridMenuProps): import("react/jsx-runtime").JSX.Element;
export interface MultiColumnMenuProvider {
	(isSupportAndDevelopment: boolean): Promise<Localized<MultiColumnMenu>>;
}
export type HamburgerMenuButtonProps = React$1.PropsWithChildren & {
	/** The handler to use for menu commands (and eventually toolbar commands). */
	commandHandler: CommandHandler;
	/**
	 * Optional reference to the "div" container that determines the where the menu should appear. If
	 * not defined, then (1,1) used.
	 */
	containerRef?: React$1.MutableRefObject<HTMLDivElement>;
	/**
	 * The delegate to use to get the menu data. If not specified or if it returns undefined, the data
	 * in normalMenu or fullMenu property will be used.
	 */
	menuProvider?: MultiColumnMenuProvider;
	/**
	 * The menu data to show when the menu is opened if the menuProvider property is not defined.
	 * (This allows for a default or test-only static menu to be used.)
	 */
	normalMenu?: Localized<MultiColumnMenu>;
	/**
	 * The menu data to show for "full" menu (when opened with the SHIFT key pressed) if the
	 * menuProvider property is not defined. (This allows for a default or test-only static menu to be
	 * used.)
	 */
	fullMenu?: Localized<MultiColumnMenu>;
	/** Additional css class(es) to help with unique styling of the sub-components */
	className?: string;
	/** Value to use as prefix for ARIA labels on interactive sub-components */
	ariaLabelPrefix?: string;
};
export function HamburgerMenuButton({ menuProvider, normalMenu, fullMenu, commandHandler, containerRef, className, ariaLabelPrefix, children, }: HamburgerMenuButtonProps): import("react/jsx-runtime").JSX.Element;
export type IconButtonProps = React$1.PropsWithChildren<{
	/** Optional unique identifier */
	id?: string;
	/**
	 * Required. Used as both the tooltip (aka, title) and the aria-label (used for accessibility,
	 * testing, etc.), unless a distinct tooltip is supplied.
	 */
	label: string;
	/**
	 * Enabled status of button
	 *
	 * @default false
	 */
	isDisabled?: boolean;
	/** Optional tooltip to display if different from the aria-label. */
	tooltip?: string;
	/** If true, no tooltip will be displayed. */
	isTooltipSuppressed?: boolean;
	/**
	 * If given, uses a negative margin to counteract the padding on one side (this is often helpful
	 * for aligning the left or right side of the icon with content above or below, without ruining
	 * the border size and shape).
	 *
	 * @default false
	 */
	adjustMarginToAlignToEdge?: "end" | "start" | false;
	/**
	 * The size of the component. small is equivalent to the dense button styling.
	 *
	 * @default false
	 */
	size: "small" | "medium" | "large";
	/** Additional css classes to help with unique styling of the button */
	className?: string;
	/** Optional click handler */
	onClick?: React$1.MouseEventHandler<HTMLButtonElement>;
}>;
/**
 * Iconic button a user can click to do something
 *
 * Thanks to MUI for heavy inspiration and documentation
 * https://mui.com/material-ui/getting-started/overview/
 */
export declare function IconButton({ id, label, isDisabled, tooltip, isTooltipSuppressed, adjustMarginToAlignToEdge, size, className, onClick, children, }: IconButtonProps): import("react/jsx-runtime").JSX.Element;
export type SearchBarProps = {
	/**
	 * Callback fired to handle the search query when button pressed
	 *
	 * @param searchQuery
	 */
	onSearch: (searchQuery: string) => void;
	/** Optional string that appears in the search bar without a search string */
	placeholder?: string;
	/** Optional boolean to set the input base to full width */
	isFullWidth?: boolean;
};
export function SearchBar({ onSearch, placeholder, isFullWidth }: SearchBarProps): import("react/jsx-runtime").JSX.Element;
export type SpinnerProps = LucideProps;
export declare const Spinner: import("react").ForwardRefExoticComponent<Omit<LucideProps, "ref"> & import("react").RefAttributes<SVGSVGElement>>;
export type TextFieldProps = {
	/** Optional unique identifier */
	id?: string;
	/**
	 * If `true`, the component is disabled.
	 *
	 * @default false
	 */
	isDisabled?: boolean;
	/**
	 * If `true`, the label is displayed in an error state.
	 *
	 * @default false
	 */
	hasError?: boolean;
	/**
	 * If `true`, the input will take up the full width of its container.
	 *
	 * @default false
	 */
	isFullWidth?: boolean;
	/** Text that gives the user instructions on what contents the TextField expects */
	helperText?: string;
	/** The title of the TextField */
	label?: string;
	/** The short hint displayed in the `input` before the user enters a value. */
	placeholder?: string;
	/**
	 * If `true`, the label is displayed as required and the `input` element is required.
	 *
	 * @default false
	 */
	isRequired?: boolean;
	/** Additional css classes to help with unique styling of the text field */
	className?: string;
	/** Starting value for the text field if it is not controlled */
	defaultValue?: string | number;
	/** Value of the text field if controlled */
	value?: string | number;
	/** Triggers when content of textfield is changed */
	onChange?: React$1.ChangeEventHandler<HTMLInputElement>;
	/** Triggers when textfield gets focus */
	onFocus?: React$1.FocusEventHandler<HTMLInputElement>;
	/** Triggers when textfield loses focus */
	onBlur?: React$1.FocusEventHandler<HTMLInputElement>;
};
/**
 * Text input field
 *
 * Thanks to Shadcn for heavy inspiration and documentation
 * https://ui.shadcn.com/docs/components/input#with-label
 */
export declare function TextField({ id, isDisabled, hasError, isFullWidth, helperText, label, placeholder, isRequired, className, defaultValue, value, onChange, onFocus, onBlur, }: TextFieldProps): import("react/jsx-runtime").JSX.Element;
export type ToolbarProps = React$1.PropsWithChildren<{
	/** The handler to use for menu commands (and eventually toolbar commands). */
	commandHandler: CommandHandler;
	/**
	 * The optional delegate to use to get the menu data. If not specified, the "hamburger" menu will
	 * not display.
	 */
	menuProvider?: MultiColumnMenuProvider;
	/** Optional unique identifier */
	id?: string;
	/** Additional css classes to help with unique styling of the toolbar */
	className?: string;
}>;
export function Toolbar({ menuProvider, commandHandler, className, id, children, }: ToolbarProps): import("react/jsx-runtime").JSX.Element;
export declare const Alert: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLDivElement> & VariantProps<(props?: ({
	variant?: "default" | "destructive" | null | undefined;
} & import("class-variance-authority/dist/types").ClassProp) | undefined) => string> & React$1.RefAttributes<HTMLDivElement>>;
export declare const AlertTitle: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLHeadingElement> & React$1.RefAttributes<HTMLParagraphElement>>;
export declare const AlertDescription: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLParagraphElement> & React$1.RefAttributes<HTMLParagraphElement>>;
export declare const Card: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLDivElement> & React$1.RefAttributes<HTMLDivElement>>;
export declare const CardHeader: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLDivElement> & React$1.RefAttributes<HTMLDivElement>>;
export declare const CardTitle: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLHeadingElement> & React$1.RefAttributes<HTMLParagraphElement>>;
export declare const CardDescription: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLParagraphElement> & React$1.RefAttributes<HTMLParagraphElement>>;
export declare const CardContent: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLDivElement> & React$1.RefAttributes<HTMLDivElement>>;
export declare const CardFooter: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLDivElement> & React$1.RefAttributes<HTMLDivElement>>;
export declare const Checkbox: React$1.ForwardRefExoticComponent<Omit<CheckboxPrimitive.CheckboxProps & React$1.RefAttributes<HTMLButtonElement>, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
export declare const DropdownMenu: React$1.FC<DropdownMenuPrimitive.DropdownMenuProps>;
export declare const DropdownMenuTrigger: React$1.ForwardRefExoticComponent<DropdownMenuPrimitive.DropdownMenuTriggerProps & React$1.RefAttributes<HTMLButtonElement>>;
export declare const DropdownMenuGroup: React$1.ForwardRefExoticComponent<DropdownMenuPrimitive.DropdownMenuGroupProps & React$1.RefAttributes<HTMLDivElement>>;
export declare const DropdownMenuPortal: React$1.FC<DropdownMenuPrimitive.DropdownMenuPortalProps>;
export declare const DropdownMenuSub: React$1.FC<DropdownMenuPrimitive.DropdownMenuSubProps>;
export declare const DropdownMenuRadioGroup: React$1.ForwardRefExoticComponent<DropdownMenuPrimitive.DropdownMenuRadioGroupProps & React$1.RefAttributes<HTMLDivElement>>;
export type DropdownMenuSubTriggerProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
	className?: string;
	inset?: boolean;
};
export type DropdownMenuSubContentProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent> & {
	className?: string;
};
export type DropdownMenuContentProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content> & {
	className?: string;
	sideOffset?: number;
};
export type DropdownMenuItemProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
	className?: string;
	inset?: boolean;
};
export type DropdownMenuCheckboxItemProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem> & {
	className?: string;
	checked?: boolean;
};
export type DropdownMenuRadioItemProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem> & {
	className?: string;
};
export type DropdownMenuLabelProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
	className?: string;
	inset?: boolean;
};
export type DropdownMenuSeparatorProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator> & {
	className?: string;
};
export type DropdownMenuShortcutProps = React$1.HTMLAttributes<HTMLSpanElement> & {
	className?: string;
};
export declare const DropdownMenuSubTrigger: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuSubTriggerProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
	inset?: boolean | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
export declare const DropdownMenuSubContent: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuSubContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
export declare const DropdownMenuContent: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
	sideOffset?: number | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
/**
 * TODO: fix: direction is not automatically handled by this component, so that shortcuts are
 * display always to the right
 */
export declare const DropdownMenuItem: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuItemProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
	inset?: boolean | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
export declare const DropdownMenuCheckboxItem: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuCheckboxItemProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
	checked?: boolean | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
export declare const DropdownMenuRadioItem: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuRadioItemProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
export declare const DropdownMenuLabel: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuLabelProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
	inset?: boolean | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
export declare const DropdownMenuSeparator: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuSeparatorProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
export declare function DropdownMenuShortcut({ className, ...props }: DropdownMenuShortcutProps): import("react/jsx-runtime").JSX.Element;
export declare namespace DropdownMenuShortcut {
	var displayName: string;
}
export interface InputProps extends React$1.InputHTMLAttributes<HTMLInputElement> {
}
export declare const Input: React$1.ForwardRefExoticComponent<InputProps & React$1.RefAttributes<HTMLInputElement>>;
export declare const Label: React$1.ForwardRefExoticComponent<Omit<LabelPrimitive.LabelProps & React$1.RefAttributes<HTMLLabelElement>, "ref"> & VariantProps<(props?: import("class-variance-authority/dist/types").ClassProp | undefined) => string> & React$1.RefAttributes<HTMLLabelElement>>;
export declare const RadioGroup: React$1.ForwardRefExoticComponent<Omit<RadioGroupPrimitive.RadioGroupProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
export declare const RadioGroupItem: React$1.ForwardRefExoticComponent<Omit<RadioGroupPrimitive.RadioGroupItemProps & React$1.RefAttributes<HTMLButtonElement>, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
export declare const Select: React$1.FC<SelectPrimitive.SelectProps>;
export declare const SelectGroup: React$1.ForwardRefExoticComponent<SelectPrimitive.SelectGroupProps & React$1.RefAttributes<HTMLDivElement>>;
export declare const SelectValue: React$1.ForwardRefExoticComponent<SelectPrimitive.SelectValueProps & React$1.RefAttributes<HTMLSpanElement>>;
export declare const SelectTrigger: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectTriggerProps & React$1.RefAttributes<HTMLButtonElement>, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
export declare const SelectScrollUpButton: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectScrollUpButtonProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
export declare const SelectScrollDownButton: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectScrollDownButtonProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
export declare const SelectContent: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
export declare const SelectLabel: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectLabelProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
export declare const SelectItem: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectItemProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
export declare const SelectSeparator: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectSeparatorProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
export declare const Separator: React$1.ForwardRefExoticComponent<Omit<SeparatorPrimitive.SeparatorProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
export type SonnerProps = React$1.ComponentProps<typeof Toaster>;
export declare function Sonner({ ...props }: SonnerProps): import("react/jsx-runtime").JSX.Element;
export declare const Slider: React$1.ForwardRefExoticComponent<Omit<SliderPrimitive.SliderProps & React$1.RefAttributes<HTMLSpanElement>, "ref"> & React$1.RefAttributes<HTMLSpanElement>>;
export declare const Switch: React$1.ForwardRefExoticComponent<Omit<SwitchPrimitives.SwitchProps & React$1.RefAttributes<HTMLButtonElement>, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
export declare const Table: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLTableElement> & {
	stickyHeader?: boolean | undefined;
} & React$1.RefAttributes<HTMLTableElement>>;
export declare const TableHeader: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLTableSectionElement> & {
	stickyHeader?: boolean | undefined;
} & React$1.RefAttributes<HTMLTableSectionElement>>;
export declare const TableBody: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLTableSectionElement> & React$1.RefAttributes<HTMLTableSectionElement>>;
export declare const TableFooter: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLTableSectionElement> & React$1.RefAttributes<HTMLTableSectionElement>>;
export declare const TableRow: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLTableRowElement> & React$1.RefAttributes<HTMLTableRowElement>>;
export declare const TableHead: React$1.ForwardRefExoticComponent<React$1.ThHTMLAttributes<HTMLTableCellElement> & React$1.RefAttributes<HTMLTableCellElement>>;
export declare const TableCell: React$1.ForwardRefExoticComponent<React$1.TdHTMLAttributes<HTMLTableCellElement> & React$1.RefAttributes<HTMLTableCellElement>>;
export declare const TableCaption: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLTableCaptionElement> & React$1.RefAttributes<HTMLTableCaptionElement>>;
export declare const Tabs: React$1.ForwardRefExoticComponent<TabsPrimitive.TabsProps & React$1.RefAttributes<HTMLDivElement>>;
export type TabsTriggerProps = React$1.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger> & {
	className?: string;
};
export declare const TabsList: React$1.ForwardRefExoticComponent<Omit<TabsPrimitive.TabsListProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
export declare const TabsTrigger: React$1.ForwardRefExoticComponent<Omit<TabsPrimitive.TabsTriggerProps & React$1.RefAttributes<HTMLButtonElement>, "ref"> & {
	className?: string | undefined;
} & React$1.RefAttributes<HTMLButtonElement>>;
export declare const TabsContent: React$1.ForwardRefExoticComponent<Omit<TabsPrimitive.TabsContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
export type LeftTabsTriggerProps = TabsTriggerProps & {
	value: string;
	ref?: React$1.Ref<HTMLButtonElement>;
};
export declare const VerticalTabs: React$1.ForwardRefExoticComponent<Omit<TabsPrimitive.TabsProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
export declare const VerticalTabsList: React$1.ForwardRefExoticComponent<Omit<TabsPrimitive.TabsListProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
export declare const VerticalTabsTrigger: React$1.ForwardRefExoticComponent<Omit<LeftTabsTriggerProps, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
export declare const VerticalTabsContent: React$1.ForwardRefExoticComponent<Omit<TabsPrimitive.TabsContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
export declare const ToggleGroup: React$1.ForwardRefExoticComponent<((Omit<ToggleGroupPrimitive.ToggleGroupSingleProps & React$1.RefAttributes<HTMLDivElement>, "ref"> | Omit<ToggleGroupPrimitive.ToggleGroupMultipleProps & React$1.RefAttributes<HTMLDivElement>, "ref">) & VariantProps<(props?: ({
	variant?: "default" | "outline" | null | undefined;
	size?: "default" | "sm" | "lg" | null | undefined;
} & import("class-variance-authority/dist/types").ClassProp) | undefined) => string>) & React$1.RefAttributes<HTMLDivElement>>;
export declare const ToggleGroupItem: React$1.ForwardRefExoticComponent<Omit<ToggleGroupPrimitive.ToggleGroupItemProps & React$1.RefAttributes<HTMLButtonElement>, "ref"> & VariantProps<(props?: ({
	variant?: "default" | "outline" | null | undefined;
	size?: "default" | "sm" | "lg" | null | undefined;
} & import("class-variance-authority/dist/types").ClassProp) | undefined) => string> & React$1.RefAttributes<HTMLButtonElement>>;
export type InstallButtonProps = {
	/** The installing boolean value determines the state of the button. */
	isInstalling: boolean;
	/** The handleClick function is called when the button is clicked. */
	handleClick: () => void;
	/** Optional text for the button. */
	buttonText?: string;
} & ButtonProps;
/**
 * The InstallButton component is a button designed for initiating installs. It includes visuals for
 * active installing and idle states.
 *
 * @param isInstalling The installing boolean value determines the state of the button.
 * @param handleClick The handleClick function is called when the button is clicked.
 * @param buttonText Optional text for the button.
 * @returns A install button.
 */
export function InstallButton({ isInstalling, handleClick, buttonText, className, ...props }: InstallButtonProps): import("react/jsx-runtime").JSX.Element;
export type EnableButtonProps = {
	/** The enabling boolean value determines the state of the button. */
	isEnabling: boolean;
	/** The handleClick function is called when the button is clicked. */
	handleClick: () => void;
} & ButtonProps;
/**
 * The EnableButton component is a button designed for initiating enabling of downloads. It includes
 * visuals for active enabling and idle states.
 *
 * @param isEnabling The enabling boolean value determines the state of the button.
 * @param handleClick The handleClick function is called when the button is clicked.
 * @returns A button that can be used to enable.
 */
export function EnableButton({ isEnabling, handleClick, className, ...props }: EnableButtonProps): import("react/jsx-runtime").JSX.Element;
export type DisableButtonProps = {
	/** The disabling boolean value determines the state of the button. */
	isDisabling: boolean;
	/** The handleClick function is called when the button is clicked. */
	handleClick: () => void;
} & ButtonProps;
/**
 * The DisableButton component is a button designed for initiating disabling of downloads. It
 * includes visuals for active disabling and idle states.
 *
 * @param isDisabling The disabling boolean value determines the state of the button.
 * @param handleClick The handleClick function is called when the button is clicked.
 * @returns A button that can be used to disable.
 */
export function DisableButton({ isDisabling, handleClick, className, ...props }: DisableButtonProps): import("react/jsx-runtime").JSX.Element;
export type UpdateButtonProps = {
	/** The updating boolean value determines the state of the button. */
	isUpdating: boolean;
	/** The handleClick function is called when the button is clicked. */
	handleClick: () => void;
} & ButtonProps;
/**
 * The UpdateButton component is a button designed for initiating updates for downloaded extensions.
 * It includes visuals for active updating and idle states.
 *
 * @param isUpdating The updating boolean value determines the state of the button.
 * @param handleClick The handleClick function is called when the button is clicked.
 * @returns A button that can be used to update.
 */
export function UpdateButton({ isUpdating, handleClick, className, ...props }: UpdateButtonProps): import("react/jsx-runtime").JSX.Element;
export interface MarkdownRendererProps {
	/** Optional unique identifier */
	id?: string;
	/** The markdown string to render */
	markdown: string;
	className?: string;
}
/**
 * This component renders markdown content given a markdown string. It uses typography styles from
 * the platform.
 *
 * @param markdown The markdown string to render.
 * @param id Optional unique identifier
 * @returns A div containing the rendered markdown content.
 */
export function MarkdownRenderer({ id, markdown, className }: MarkdownRendererProps): import("react/jsx-runtime").JSX.Element;
export declare enum DropdownMenuItemType {
	Check = 0,
	Radio = 1
}
export type DropdownItem = {
	/** The label is the text that will be displayed on the dropdown item. */
	label: string;
	/** The itemType determines the DropdownMenuItemType type as either Check or Radio. */
	itemType: DropdownMenuItemType;
	/** The onClick function is called when the item is clicked. */
	onClick: () => void;
};
export type DropdownGroup = {
	/**
	 * The label is the text that will be displayed on the dropdown group. It is used to categorize
	 * the items in the group.
	 */
	label: string;
	/** The items array contains the items that will be displayed in the dropdown group */
	items: DropdownItem[];
};
export type FilterDropdownProps = {
	/** Object unique identifier */
	id?: string;
	/** The groups array contains the groups that will be displayed in the dropdown */
	groups: DropdownGroup[];
};
/**
 * The FilterDropdown component is a dropdown designed for filtering content. It includes groups of
 * items that can be checkboxes or radio items.
 *
 * @param id Optional unique identifier
 * @param groups The groups array contains the groups that will be displayed in the dropdown
 * @returns A filter dropdown.
 */
export function FilterDropdown({ id, groups }: FilterDropdownProps): import("react/jsx-runtime").JSX.Element;
/**
 * The FilterButton component is a button designed for initiating filtering of data. It is designed
 * to be used with the dropdown menu. It uses forwardRef to pass the button to the dropdown trigger
 * asChild.
 *
 * @returns A button that can be used to filter.
 */
export declare const FilterButton: import("react").ForwardRefExoticComponent<import("react").RefAttributes<HTMLButtonElement>>;
export interface NoExtensionsFoundProps {
	/** Optional unique identifier */
	id?: string;
	/** The message to display */
	message: string;
}
/**
 * This component displays a message to the user when no extensions are found in the marketplace.
 *
 * @param id Optional unique identifier
 * @param message The message to display.
 * @returns {JSX.Element} - Returns the message component that displays the message to the user.
 */
export function NoExtensionsFound({ id, message }: NoExtensionsFoundProps): import("react/jsx-runtime").JSX.Element;
/** Interface that stores the parameters passed to the More Info component */
export interface MoreInfoProps {
	/** Optional unique identifier */
	id?: string;
	/** The category of the extension */
	category: string;
	/** The number of downloads for the extension */
	downloads: Record<string, number>;
	/** The languages supported by the extension */
	languages: string[];
	/** The URL to the more info page of the extension */
	moreInfoUrl: string;
}
/**
 * This component displays the more info section of the extension which includes the category,
 * number of downloads, languages, and links to the website and support
 *
 * @param id Optional unique identifier
 * @param category The category of the extension
 * @param downloads The number of downloads for the extension
 * @param languages The languages supported by the extension
 * @param moreInfoUrl The URL to the more info page of the extension
 * @returns {JSX.Element} - Returns the more info component that displays the category, number of
 *   downloads, languages, and links to the website and support
 */
export function MoreInfo({ id, category, downloads, languages, moreInfoUrl, }: MoreInfoProps): import("react/jsx-runtime").JSX.Element;
export type VersionInformation = {
	/** Date the version was published */
	date: string;
	/** Description of the changes in the version */
	description: string;
};
/** Type to store the version history information */
export type VersionHistoryType = Record<string, VersionInformation>;
/** Interface that stores the parameters passed to the Version History component */
export interface VersionHistoryProps {
	/** Optional unique identifier */
	id?: string;
	/** Object containing the versions mapped with their information */
	versionHistory: VersionHistoryType;
}
/**
 * Component to render the version history information shown in the footer component. Lists the 5
 * most recent versions, with the options to show all versions by pressing a button.
 *
 * @param versionHistory Object containing the versions mapped with their information
 * @param id Optional unique identifier
 * @returns Rendered version history for the Footer component
 */
export function VersionHistory({ id, versionHistory }: VersionHistoryProps): import("react/jsx-runtime").JSX.Element;
/** Interface to store the parameters passed to the Footer component */
export interface FooterProps {
	/** Optional unique identifier */
	id?: string;
	/** Name of the publisher */
	publisherDisplayName: string;
	/** Size of the extension file in bytes */
	fileSize: number;
	/** List of language codes supported by the extension */
	locales: string[];
	/** Object containing the version history mapped with their information */
	versionHistory: VersionHistoryType;
}
/**
 * Component to render the footer for the extension details which contains information on the
 * publisher, version history, languages, and file size.
 *
 * @param id Optional unique identifier
 * @param publisherDisplayName Name of the publisher
 * @param fileSize Size of the extension file in bytes
 * @param locales List of language codes supported by the extension
 * @param versionHistory Object containing the version history mapped with their information
 * @returns The rendered Footer component
 */
export function Footer({ id, publisherDisplayName, fileSize, locales, versionHistory, }: FooterProps): import("react/jsx-runtime").JSX.Element;
/**
 * Adds an event handler to an event so the event handler runs when the event is emitted. Use
 * `papi.network.getNetworkEvent` to use a networked event with this hook.
 *
 * @param event The event to subscribe to.
 *
 *   - If event is a `PlatformEvent`, that event will be used
 *   - If event is undefined, the callback will not be subscribed. Useful if the event is not yet
 *       available for example
 *
 * @param eventHandler The callback to run when the event is emitted
 *
 *   WARNING: MUST BE STABLE - const or wrapped in useCallback. The reference must not be updated
 *   every render
 */
export declare const useEvent: <T>(event: PlatformEvent<T> | undefined, eventHandler: PlatformEventHandler<T>) => void;
/**
 * Adds an event handler to an asynchronously subscribing/unsubscribing event so the event handler
 * runs when the event is emitted. Use `papi.network.getNetworkEvent` to use a networked event with
 * this hook.
 *
 * @param event The asynchronously (un)subscribing event to subscribe to.
 *
 *   - If event is a `PlatformEvent` or `PlatformEventAsync`, that event will be used
 *   - If event is undefined, the callback will not be subscribed. Useful if the event is not yet
 *       available for example
 *
 * @param eventHandler The callback to run when the event is emitted
 *
 *   WARNING: MUST BE STABLE - const or wrapped in useCallback. The reference must not be updated
 *   every render
 */
export declare const useEventAsync: <T>(event: PlatformEvent<T> | PlatformEventAsync<T> | undefined, eventHandler: PlatformEventHandler<T>) => void;
export type UsePromiseOptions = {
	/**
	 * Whether to leave the value as the most recent resolved promise value or set it back to
	 * defaultValue while running the promise again. Defaults to true
	 */
	preserveValue?: boolean;
};
/**
 * Awaits a promise and returns a loading value while the promise is unresolved
 *
 * @param promiseFactoryCallback A function that returns the promise to await. If this callback is
 *   undefined, the current value will be returned (defaultValue unless it was previously changed
 *   and `options.preserveValue` is true), and there will be no loading.
 *
 *   WARNING: MUST BE STABLE - const or wrapped in useCallback. The reference must not be updated
 *   every render
 * @param defaultValue The initial value to return while first awaiting the promise. If
 *   `options.preserveValue` is false, this value is also shown while awaiting the promise on
 *   subsequent calls.
 *
 *   Note: this parameter is internally assigned to a `ref`, so changing it will not cause any hooks
 *   to re-run with its new value. This means that, if the `promiseFactoryCallback` changes and
 *   `options.preserveValue` is `false`, the returned value will be set to the current
 *   `defaultValue`. However, the returned value will not be updated if`defaultValue` changes.
 * @param options Various options for adjusting how this hook runs the `promiseFactoryCallback`
 *
 *   Note: this parameter is internally assigned to a `ref`, so changing it will not cause any hooks
 *   to re-run with its new value. However, the latest `options.preserveValue` will always be used
 *   appropriately to determine whether to preserve the returned value when changing the
 *   `promiseFactoryCallback`
 * @returns `[value, isLoading]`
 *
 *   - `value`: the current value for the promise, either the defaultValue or the resolved promise value
 *   - `isLoading`: whether the promise is waiting to be resolved
 */
export declare const usePromise: <T>(promiseFactoryCallback: (() => Promise<T>) | undefined, defaultValue: T, options?: UsePromiseOptions) => [
	value: T,
	isLoading: boolean
];
/**
 * Tailwind and CSS class application helper function. Uses
 * [`clsx`](https://www.npmjs.com/package/clsx) to make it easy to apply classes conditionally using
 * object syntax, and uses [`tailwind-merge`](https://www.npmjs.com/package/tailwind-merge) to make
 * it easy to merge/overwrite Tailwind classes in a programmer-logic-friendly way.
 *
 * Note: `tailwind-merge` is configured to use the prefix `tw-`, so you must use the same prefix
 * with any Tailwind classes you use with this function to successfully overwrite other Tailwind
 * classes. `platform-bible-react` is configured to use `tw-` as its Tailwind prefix, so any
 * Tailwind classes you pass into `platform-bible-react` components will be compared using the `tw-`
 * prefix.
 *
 * This function was popularized by
 * [shadcn/ui](https://ui.shadcn.com/docs/installation/manual#add-a-cn-helper). See [ByteGrad's
 * explanation video](https://www.youtube.com/watch?v=re2JFITR7TI) for more information.
 *
 * @example
 *
 * ```typescript
 * const borderShouldBeBlue = true;
 * const textShouldBeRed = true;
 * const heightShouldBe20 = false;
 * const classString = cn(
 *   'tw-bg-primary tw-h-10 tw-text-primary-foreground',
 *   'tw-bg-secondary',
 *   {
 *     'tw-border-blue-500': borderShouldBeBlue,
 *     'tw-text-red-500': textShouldBeRed,
 *     'tw-h-20': heightShouldBe20,
 *   },
 *   'some-class',
 * );
 * ```
 *
 * The resulting `classString` is `'tw-h-10 tw-bg-secondary tw-border-blue-500 tw-text-red-500
 * some-class'`
 *
 * - Notice that `'tw-bg-secondary'`, specified later, overwrote `'tw-bg-primary'`, specified earlier,
 *   because they are Tailwind classes that affect the same css property
 * - Notice that `'tw-text-red-500'`, specified later, overwrote `'tw-text-primary-foreground'`,
 *   specified earlier, because they are Tailwind classes that affect the same css property
 * - Notice that `'tw-h-20'`, specified later, did not overwrite `'tw-h-10'`, specified earlier,
 *   because `'tw-h-20'` is part of a conditional class object and its value evaluated to `false`;
 *   therefore it was not applied
 * - Notice that `'some-class'` was applied. This function is not limited only to Tailwind classes.
 *
 *
 * @param inputs Class strings or `clsx` conditional class objects to merge. Tailwind classes
 *   specified later in the arguments overwrite similar Tailwind classes specified earlier in the
 *   arguments
 * @returns Class string containing all applicable classes from the arguments based on the rules
 *   described above
 */
export declare function cn(...inputs: ClassValue[]): string;

export {
	sonner,
};

export {};
